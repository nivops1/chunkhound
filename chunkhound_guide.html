<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChunkHound Interactive Guide - From DevOps to AI Search</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            color: white;
            padding: 40px 20px;
            margin-bottom: 30px;
        }

        header h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        header p {
            font-size: 1.3em;
            opacity: 0.9;
        }

        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.3);
            z-index: 1000;
        }

        .progress-bar-fill {
            height: 100%;
            background: #4ade80;
            width: 0%;
            transition: width 0.3s ease;
        }

        .nav {
            position: sticky;
            top: 20px;
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 100;
        }

        .nav h3 {
            margin-bottom: 15px;
            color: #667eea;
        }

        .nav ul {
            list-style: none;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .nav a {
            display: inline-block;
            padding: 8px 16px;
            background: #f3f4f6;
            color: #667eea;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.3s ease;
            font-size: 0.9em;
        }

        .nav a:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
        }

        .section {
            background: white;
            border-radius: 12px;
            padding: 40px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .section h2 {
            color: #667eea;
            font-size: 2.5em;
            margin-bottom: 20px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        .section h3 {
            color: #764ba2;
            font-size: 1.8em;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        .section h4 {
            color: #667eea;
            font-size: 1.3em;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .concept-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 12px;
            margin: 20px 0;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .concept-box h3 {
            color: white;
            margin-top: 0;
        }

        .interactive-demo {
            background: #f9fafb;
            border: 2px solid #667eea;
            border-radius: 12px;
            padding: 30px;
            margin: 20px 0;
        }

        .interactive-demo h4 {
            color: #667eea;
            margin-top: 0;
        }

        .demo-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #d1d5db;
            border-radius: 6px;
            font-size: 1em;
            margin: 10px 0;
            font-family: inherit;
        }

        .demo-button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .demo-button:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .demo-output {
            background: white;
            border: 2px solid #d1d5db;
            border-radius: 6px;
            padding: 15px;
            margin-top: 15px;
            min-height: 60px;
            font-family: 'Courier New', monospace;
        }

        .code-block {
            background: #1e293b;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
        }

        .code-block pre {
            margin: 0;
            white-space: pre-wrap;
        }

        .highlight {
            background: #fef3c7;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 600;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 15px;
            text-align: left;
            border: 1px solid #e5e7eb;
        }

        .comparison-table th {
            background: #667eea;
            color: white;
            font-weight: 600;
        }

        .comparison-table tr:nth-child(even) {
            background: #f9fafb;
        }

        .visual-diagram {
            background: white;
            border: 2px solid #667eea;
            border-radius: 12px;
            padding: 30px;
            margin: 20px 0;
            text-align: center;
        }

        .architecture-box {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            margin: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .arrow {
            font-size: 2em;
            color: #667eea;
            margin: 0 10px;
        }

        .tip-box {
            background: #ecfdf5;
            border-left: 4px solid #10b981;
            padding: 20px;
            margin: 20px 0;
            border-radius: 6px;
        }

        .tip-box strong {
            color: #10b981;
            display: block;
            margin-bottom: 10px;
        }

        .warning-box {
            background: #fef2f2;
            border-left: 4px solid #ef4444;
            padding: 20px;
            margin: 20px 0;
            border-radius: 6px;
        }

        .warning-box strong {
            color: #ef4444;
            display: block;
            margin-bottom: 10px;
        }

        .metric-card {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin: 10px;
            display: inline-block;
            min-width: 200px;
            text-align: center;
        }

        .metric-card h4 {
            color: white;
            margin: 0 0 10px 0;
            font-size: 1em;
        }

        .metric-card .value {
            font-size: 2em;
            font-weight: bold;
        }

        .flex-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 20px 0;
        }

        .flex-item {
            flex: 1;
            min-width: 300px;
            background: #f9fafb;
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #e5e7eb;
        }

        .vector-viz {
            display: inline-block;
            padding: 5px 10px;
            background: #667eea;
            color: white;
            border-radius: 4px;
            margin: 3px;
            font-family: monospace;
            font-size: 0.9em;
        }

        footer {
            text-align: center;
            color: white;
            padding: 40px 20px;
            margin-top: 50px;
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 2em;
            }

            .section {
                padding: 20px;
            }

            .nav ul {
                flex-direction: column;
            }

            .flex-item {
                min-width: 100%;
            }
        }

        .toggle-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .toggle-content.active {
            max-height: 2000px;
        }

        .toggle-button {
            background: #f3f4f6;
            border: 2px solid #667eea;
            color: #667eea;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            margin: 10px 0;
            font-size: 1em;
            width: 100%;
            text-align: left;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .toggle-button:hover {
            background: #667eea;
            color: white;
        }

        .toggle-button::after {
            content: " ‚ñº";
            float: right;
        }

        .toggle-button.active::after {
            content: " ‚ñ≤";
        }
    </style>
</head>
<body>
    <div class="progress-bar">
        <div class="progress-bar-fill" id="progressBar"></div>
    </div>

    <header>
        <h1>ChunkHound Interactive Guide</h1>
        <p>From DevOps Engineer to AI-Powered Code Search Expert</p>
    </header>

    <div class="container">
        <nav class="nav">
            <h3>Quick Navigation</h3>
            <ul>
                <li><a href="#intro">Introduction</a></li>
                <li><a href="#search-basics">Search Basics</a></li>
                <li><a href="#embeddings">Embeddings</a></li>
                <li><a href="#vector-db">Vector Databases</a></li>
                <li><a href="#architecture">Architecture</a></li>
                <li><a href="#concurrency">Concurrency</a></li>
                <li><a href="#performance">Performance</a></li>
                <li><a href="#mcp">MCP Protocol</a></li>
                <li><a href="#devops">DevOps Use Cases</a></li>
            </ul>
        </nav>

        <!-- Section 1: Introduction -->
        <section id="intro" class="section">
            <h2>What is ChunkHound?</h2>

            <p>Imagine you're debugging a production issue at 3 AM. You know the error is related to "authentication timeout" but you don't know where in the codebase to look. Traditional tools like <code>grep</code> will find exact text matches, but what if the relevant code uses different terminology like "auth expiration" or "session timeout"?</p>

            <div class="concept-box">
                <h3>ChunkHound = Semantic Search + Regex Search</h3>
                <p><strong>Semantic Search:</strong> Understands the <em>meaning</em> of your query, not just exact text matches.</p>
                <p><strong>Regex Search:</strong> Traditional pattern matching for exact searches.</p>
                <p><strong>AI Integration:</strong> Connects to AI assistants via MCP (Model Context Protocol) to provide context-aware code understanding.</p>
            </div>

            <div class="tip-box">
                <strong>For DevOps Engineers:</strong>
                Think of ChunkHound as a "smart grep" that understands concepts. When you search for "database connection pooling," it finds code about connection management, even if those exact words aren't in the code.
            </div>

            <h3>The Problem ChunkHound Solves</h3>

            <div class="flex-container">
                <div class="flex-item">
                    <h4>Traditional Search (grep)</h4>
                    <ul>
                        <li>‚ùå Only finds exact text matches</li>
                        <li>‚ùå Misses synonyms and related concepts</li>
                        <li>‚ùå No understanding of code semantics</li>
                        <li>‚ùå Manual context gathering</li>
                    </ul>
                </div>
                <div class="flex-item">
                    <h4>ChunkHound</h4>
                    <ul>
                        <li>‚úÖ Finds semantically similar code</li>
                        <li>‚úÖ Understands programming concepts</li>
                        <li>‚úÖ AI-powered context extraction</li>
                        <li>‚úÖ Automatic relevance ranking</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Section 2: Search Basics -->
        <section id="search-basics" class="section">
            <h2>Search Basics: How Computers Understand Text</h2>

            <h3>Traditional Text Search</h3>
            <p>When you run <code>grep "database" *.py</code>, the computer looks for the exact sequence of characters "database". Simple and fast, but limited.</p>

            <div class="code-block">
<pre># Traditional search finds:
db.connect()          # ‚ùå Missed: doesn't contain "database"
database.query()      # ‚úÖ Found: exact match
DatabaseConnection()  # ‚úÖ Found: contains "database"
establish_db_link()   # ‚ùå Missed: synonym not recognized</pre>
            </div>

            <h3>Semantic Search: Understanding Meaning</h3>
            <p>Semantic search converts text into <span class="highlight">vectors (numerical representations)</span> that capture meaning. Similar concepts get similar numbers.</p>

            <div class="interactive-demo">
                <h4>Try It: Compare Text Similarity</h4>
                <p>Enter two phrases and see how similar they are conceptually:</p>
                <input type="text" class="demo-input" id="text1" placeholder="e.g., database connection" value="database connection">
                <input type="text" class="demo-input" id="text2" placeholder="e.g., establish DB link" value="establish DB link">
                <button class="demo-button" onclick="compareSimilarity()">Compare Similarity</button>
                <div class="demo-output" id="similarityOutput">Results will appear here...</div>
            </div>

            <div class="tip-box">
                <strong>Key Insight:</strong>
                Words with similar meanings get mapped to similar numerical coordinates in "meaning space". It's like plotting related concepts on a map where related ideas are geographically close.
            </div>
        </section>

        <!-- Section 3: Embeddings & Vectors -->
        <section id="embeddings" class="section">
            <h2>Embeddings: The Magic Behind Semantic Search</h2>

            <div class="concept-box">
                <h3>What is an Embedding?</h3>
                <p>An embedding is a list of numbers (a vector) that represents the meaning of text. Think of it as GPS coordinates in "meaning space".</p>
            </div>

            <h3>Simple Example</h3>
            <p>Imagine we had a 3-dimensional "meaning space" (real embeddings use 384-1536 dimensions!):</p>

            <div class="visual-diagram">
                <div style="margin: 20px 0;">
                    <p><strong>"database"</strong></p>
                    <span class="vector-viz">0.8</span>
                    <span class="vector-viz">0.2</span>
                    <span class="vector-viz">0.1</span>
                    <p style="margin-top: 10px; font-size: 0.9em; color: #666;">(High on "data storage" axis)</p>
                </div>

                <div style="margin: 20px 0;">
                    <p><strong>"connection"</strong></p>
                    <span class="vector-viz">0.3</span>
                    <span class="vector-viz">0.9</span>
                    <span class="vector-viz">0.1</span>
                    <p style="margin-top: 10px; font-size: 0.9em; color: #666;">(High on "networking" axis)</p>
                </div>

                <div style="margin: 20px 0;">
                    <p><strong>"database connection"</strong></p>
                    <span class="vector-viz">0.7</span>
                    <span class="vector-viz">0.7</span>
                    <span class="vector-viz">0.1</span>
                    <p style="margin-top: 10px; font-size: 0.9em; color: #666;">(High on both axes!)</p>
                </div>
            </div>

            <h3>How Embeddings Are Created</h3>
            <p>ChunkHound uses AI models to convert text into embeddings:</p>

            <div class="code-block">
<pre># Step 1: Break code into chunks
code_chunk = "def authenticate_user(username, password):"

# Step 2: Send to embedding model (OpenAI, Ollama, VoyageAI)
embedding = embedding_model.embed(code_chunk)

# Step 3: Get back a vector (list of numbers)
# Real example with 384 dimensions:
embedding = [0.023, -0.157, 0.391, ..., 0.102]  # 384 numbers total
</pre>
            </div>

            <h3>Why Embeddings Matter</h3>
            <ul>
                <li><strong>Semantic Similarity:</strong> Similar meanings ‚Üí similar vectors</li>
                <li><strong>Fast Search:</strong> Math operations on vectors are very fast</li>
                <li><strong>Language Independent:</strong> Can work across different programming languages</li>
                <li><strong>Context Aware:</strong> Captures the meaning of code, not just keywords</li>
            </ul>

            <div class="warning-box">
                <strong>Performance Critical:</strong>
                Creating embeddings is slow! ChunkHound batches them for 100x speedup:
                <ul>
                    <li>Single embedding: ~100ms each √ó 1000 = 100 seconds</li>
                    <li>Batched (100 at once): ~1 second for all 1000</li>
                </ul>
            </div>

            <h3>Real ChunkHound Embedding Providers</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Provider</th>
                        <th>Use Case</th>
                        <th>Speed</th>
                        <th>Cost</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>OpenAI</strong></td>
                        <td>Production, high quality</td>
                        <td>Fast (API)</td>
                        <td>Paid</td>
                    </tr>
                    <tr>
                        <td><strong>Ollama</strong></td>
                        <td>Local development, privacy</td>
                        <td>Medium (local GPU)</td>
                        <td>Free</td>
                    </tr>
                    <tr>
                        <td><strong>VoyageAI</strong></td>
                        <td>Code-specific embeddings</td>
                        <td>Fast (API)</td>
                        <td>Paid</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <!-- Section 4: Vector Databases -->
        <section id="vector-db" class="section">
            <h2>Vector Databases: Storing & Searching Embeddings</h2>

            <h3>Why Not Use Regular Databases?</h3>
            <p>Regular databases (PostgreSQL, MySQL) are great for exact matches:</p>
            <div class="code-block">
<pre>SELECT * FROM users WHERE username = 'john'  -- Exact match</pre>
            </div>

            <p>But for semantic search, we need to find <span class="highlight">similar vectors</span>:</p>
            <div class="code-block">
<pre>SELECT * FROM code_chunks
WHERE embedding_vector IS_SIMILAR_TO query_vector
ORDER BY similarity DESC
LIMIT 10  -- Top 10 most similar chunks</pre>
            </div>

            <div class="concept-box">
                <h3>Vector Database = Specialized Storage for Embeddings</h3>
                <p>Optimized for finding "nearby" vectors in high-dimensional space. Think of it as a spatial database for meaning.</p>
            </div>

            <h3>ChunkHound's Vector Database Options</h3>

            <button class="toggle-button" onclick="toggleSection('duckdb-section')">
                DuckDB - Primary Database
            </button>
            <div id="duckdb-section" class="toggle-content">
                <div style="padding: 20px;">
                    <h4>DuckDB Overview</h4>
                    <ul>
                        <li><strong>Type:</strong> Embedded analytical database (like SQLite but for analytics)</li>
                        <li><strong>Use Case:</strong> Default for ChunkHound, great for development</li>
                        <li><strong>Pros:</strong> Fast, no setup, single file, SQL queries</li>
                        <li><strong>Cons:</strong> Single-threaded only (critical limitation!)</li>
                    </ul>

                    <div class="warning-box">
                        <strong>Critical Constraint:</strong>
                        DuckDB is SINGLE-THREADED. Multiple threads accessing DuckDB simultaneously = SEGFAULT (crash) or data corruption. ChunkHound wraps all DuckDB access in SerialDatabaseExecutor to prevent this.
                    </div>

                    <div class="code-block">
<pre># DuckDB storage structure
chunks.duckdb           # Main database file
‚îú‚îÄ‚îÄ files_table         # Metadata about indexed files
‚îú‚îÄ‚îÄ chunks_table        # Code chunks with embeddings
‚îî‚îÄ‚îÄ hnsw_index          # Fast vector search index</pre>
                    </div>
                </div>
            </div>

            <button class="toggle-button" onclick="toggleSection('lancedb-section')">
                LanceDB - Alternative with Multi-Process Support
            </button>
            <div id="lancedb-section" class="toggle-content">
                <div style="padding: 20px;">
                    <h4>LanceDB Overview</h4>
                    <ul>
                        <li><strong>Type:</strong> Modern columnar vector database</li>
                        <li><strong>Use Case:</strong> Production, multi-process workloads</li>
                        <li><strong>Pros:</strong> Multi-process safe (MVCC), fast, built for ML</li>
                        <li><strong>Cons:</strong> Fragment management, deduplication needed</li>
                    </ul>

                    <h4>LanceDB Concurrency Model</h4>
                    <p>LanceDB uses MVCC (Multi-Version Concurrency Control) - like Git for databases:</p>
                    <ul>
                        <li><strong>Read Concurrency:</strong> Multiple processes read simultaneously (each sees a snapshot)</li>
                        <li><strong>Write Concurrency:</strong> Automatic conflict resolution with retries</li>
                        <li><strong>Within Process:</strong> ChunkHound still serializes (SerialDatabaseExecutor)</li>
                    </ul>

                    <div class="code-block">
<pre># LanceDB storage structure
chunks.lance/
‚îú‚îÄ‚îÄ _versions/          # MVCC version snapshots
‚îú‚îÄ‚îÄ _indices/           # Vector indexes
‚îî‚îÄ‚îÄ data_*.lance        # Data fragments</pre>
                    </div>

                    <div class="warning-box">
                        <strong>Fragment Management:</strong>
                        LanceDB creates a new fragment for each write. Too many fragments = duplicate results in queries. ChunkHound deduplicates all multi-result queries to ensure correctness.
                    </div>
                </div>
            </div>

            <h3>Vector Search: How It Works</h3>
            <div class="visual-diagram">
                <p><strong>Finding Similar Code</strong></p>
                <div style="margin: 30px 0;">
                    <div class="architecture-box">1. Query<br/>"auth timeout"</div>
                    <span class="arrow">‚Üí</span>
                    <div class="architecture-box">2. Convert to Vector<br/>[0.23, 0.81, ...]</div>
                    <span class="arrow">‚Üí</span>
                    <div class="architecture-box">3. Find Similar Vectors<br/>in Database</div>
                    <span class="arrow">‚Üí</span>
                    <div class="architecture-box">4. Return Ranked<br/>Results</div>
                </div>
            </div>

            <h3>Vector Indexes: The Speed Secret</h3>
            <p>Searching millions of vectors would be slow without indexes. ChunkHound uses <span class="highlight">HNSW (Hierarchical Navigable Small World)</span> indexes:</p>

            <ul>
                <li><strong>Without Index:</strong> Compare query to every vector (slow)</li>
                <li><strong>With HNSW:</strong> Navigate a graph structure (100x faster)</li>
            </ul>

            <div class="tip-box">
                <strong>Performance Trick:</strong>
                When bulk-inserting > 50 embeddings, ChunkHound drops the index first, inserts all data, then rebuilds the index. This gives 20x speedup!
            </div>
        </section>

        <!-- Section 5: Architecture -->
        <section id="architecture" class="section">
            <h2>ChunkHound Architecture</h2>

            <h3>High-Level Flow</h3>
            <div class="visual-diagram">
                <div style="text-align: left; max-width: 800px; margin: 0 auto;">
                    <div class="architecture-box" style="display: block; margin: 10px 0;">
                        1. User: "Index this codebase"
                    </div>
                    <div style="text-align: center; font-size: 2em; color: #667eea;">‚Üì</div>
                    <div class="architecture-box" style="display: block; margin: 10px 0;">
                        2. Parser: Parse files ‚Üí Extract code chunks
                    </div>
                    <div style="text-align: center; font-size: 2em; color: #667eea;">‚Üì</div>
                    <div class="architecture-box" style="display: block; margin: 10px 0;">
                        3. Embedding Service: Convert chunks ‚Üí Vectors (batched!)
                    </div>
                    <div style="text-align: center; font-size: 2em; color: #667eea;">‚Üì</div>
                    <div class="architecture-box" style="display: block; margin: 10px 0;">
                        4. Database: Store chunks + vectors
                    </div>
                    <div style="text-align: center; font-size: 2em; color: #667eea;">‚Üì</div>
                    <div class="architecture-box" style="display: block; margin: 10px 0;">
                        5. Ready for Search!
                    </div>
                </div>
            </div>

            <h3>Component Layers</h3>
            <div class="flex-container">
                <div class="flex-item">
                    <h4>Interfaces (Protocols)</h4>
                    <p>Abstract contracts defining "what" without "how"</p>
                    <ul>
                        <li>DatabaseProvider</li>
                        <li>EmbeddingProvider</li>
                        <li>Parser</li>
                    </ul>
                    <div class="tip-box" style="margin-top: 10px;">
                        <strong>DevOps Analogy:</strong> Like interface definitions in Terraform or API contracts in OpenAPI specs.
                    </div>
                </div>

                <div class="flex-item">
                    <h4>Providers (Implementations)</h4>
                    <p>Concrete implementations of interfaces</p>
                    <ul>
                        <li>DuckDBProvider</li>
                        <li>LanceDBProvider</li>
                        <li>OpenAIEmbeddingProvider</li>
                        <li>TreeSitterParser</li>
                    </ul>
                    <div class="tip-box" style="margin-top: 10px;">
                        <strong>DevOps Analogy:</strong> Like choosing AWS vs Azure vs GCP - same interface, different implementation.
                    </div>
                </div>

                <div class="flex-item">
                    <h4>Services (Orchestration)</h4>
                    <p>Business logic and optimization</p>
                    <ul>
                        <li>EmbeddingService (batching)</li>
                        <li>IndexingService (coordination)</li>
                        <li>SearchService (ranking)</li>
                    </ul>
                    <div class="tip-box" style="margin-top: 10px;">
                        <strong>DevOps Analogy:</strong> Like Kubernetes controllers - orchestrate lower-level resources for high-level goals.
                    </div>
                </div>
            </div>

            <h3>Directory Structure Explained</h3>
            <div class="code-block">
<pre>chunkhound/
‚îú‚îÄ‚îÄ interfaces/        # Contracts (what you can do)
‚îÇ   ‚îú‚îÄ‚îÄ database.py
‚îÇ   ‚îú‚îÄ‚îÄ embedding.py
‚îÇ   ‚îî‚îÄ‚îÄ parser.py
‚îú‚îÄ‚îÄ providers/         # Implementations (how it's done)
‚îÇ   ‚îú‚îÄ‚îÄ databases/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ duckdb_provider.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ lancedb_provider.py
‚îÇ   ‚îú‚îÄ‚îÄ embeddings/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ openai_provider.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ollama_provider.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ voyage_provider.py
‚îÇ   ‚îî‚îÄ‚îÄ parsers/
‚îÇ       ‚îú‚îÄ‚îÄ treesitter_parser.py
‚îÇ       ‚îî‚îÄ‚îÄ text_parser.py
‚îú‚îÄ‚îÄ services/          # Orchestration (optimization & batching)
‚îÇ   ‚îú‚îÄ‚îÄ embedding_service.py
‚îÇ   ‚îú‚îÄ‚îÄ indexing_service.py
‚îÇ   ‚îî‚îÄ‚îÄ search_service.py
‚îú‚îÄ‚îÄ mcp_server/        # MCP protocol integration
‚îÇ   ‚îú‚îÄ‚îÄ stdio.py       # Claude Desktop integration
‚îÇ   ‚îú‚îÄ‚îÄ http_server.py # HTTP API
‚îÇ   ‚îî‚îÄ‚îÄ tools.py       # AI tools registry
‚îî‚îÄ‚îÄ core/              # Data models & configuration
    ‚îú‚îÄ‚îÄ models.py
    ‚îî‚îÄ‚îÄ config.py</pre>
            </div>

            <h3>Key Design Principles</h3>
            <ul>
                <li><strong>Dependency Injection:</strong> Services receive providers via constructor (easy testing & swapping)</li>
                <li><strong>Single Responsibility:</strong> Each component has one job</li>
                <li><strong>Batching Everywhere:</strong> Never process one item when you can batch 100</li>
                <li><strong>Thread Safety:</strong> SerialDatabaseProvider wraps all DB access in single thread</li>
            </ul>
        </section>

        <!-- Section 6: Concurrency Model -->
        <section id="concurrency" class="section">
            <h2>Concurrency Model: Parallel Processing, Serial Storage</h2>

            <div class="concept-box">
                <h3>The Golden Rule</h3>
                <p><strong>Parsing: PARALLEL</strong> (CPU-bound, parallelizes well)</p>
                <p><strong>Database Operations: SERIAL</strong> (Single-threaded to prevent corruption)</p>
            </div>

            <h3>Why This Matters</h3>
            <p>Imagine indexing 10,000 files:</p>

            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Approach</th>
                        <th>Parsing Time</th>
                        <th>DB Insert Time</th>
                        <th>Total</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Sequential (bad)</td>
                        <td>100 seconds</td>
                        <td>50 seconds</td>
                        <td>150 seconds</td>
                    </tr>
                    <tr>
                        <td>All Parallel (CRASHES!)</td>
                        <td>25 seconds</td>
                        <td>üí• SEGFAULT</td>
                        <td>‚ùå FAIL</td>
                    </tr>
                    <tr>
                        <td>ChunkHound (optimal)</td>
                        <td>25 seconds</td>
                        <td>1 second (batched)</td>
                        <td>26 seconds</td>
                    </tr>
                </tbody>
            </table>

            <h3>The SerialDatabaseExecutor</h3>
            <p>ChunkHound's secret weapon for thread safety:</p>

            <div class="code-block">
<pre># All database calls go through this wrapper
class SerialDatabaseExecutor:
    def __init__(self):
        self._executor = ThreadPoolExecutor(max_workers=1)  # Single thread!

    async def execute(self, func):
        # Forces all DB operations through one thread
        return await loop.run_in_executor(self._executor, func)</pre>
            </div>

            <div class="tip-box">
                <strong>DevOps Analogy:</strong>
                Think of SerialDatabaseExecutor as a job queue (like Jenkins or GitLab CI) that only runs one job at a time. All database requests queue up and execute one by one.
            </div>

            <h3>Multi-Process Scenarios</h3>
            <p>What happens when multiple ChunkHound processes run simultaneously?</p>

            <button class="toggle-button" onclick="toggleSection('duckdb-concurrent')">
                DuckDB Multi-Process Behavior
            </button>
            <div id="duckdb-concurrent" class="toggle-content">
                <div style="padding: 20px;">
                    <div class="warning-box">
                        <strong>NOT SAFE:</strong> DuckDB has no multi-process coordination. Running multiple ChunkHound processes pointing to the same DuckDB file will cause:
                        <ul>
                            <li>Database locks</li>
                            <li>Data corruption</li>
                            <li>Segmentation faults</li>
                        </ul>
                        <strong>Solution:</strong> Use LanceDB for multi-process workloads, or ensure only one ChunkHound process accesses DuckDB.
                    </div>
                </div>
            </div>

            <button class="toggle-button" onclick="toggleSection('lancedb-concurrent')">
                LanceDB Multi-Process Behavior
            </button>
            <div id="lancedb-concurrent" class="toggle-content">
                <div style="padding: 20px;">
                    <div class="tip-box">
                        <strong>SAFE:</strong> LanceDB uses MVCC (Multi-Version Concurrency Control) for multi-process coordination:
                        <ul>
                            <li>Each process gets a consistent snapshot for reads</li>
                            <li>Writes use conflict-free upsert with automatic retries</li>
                            <li>No locks or manual coordination needed</li>
                        </ul>
                    </div>

                    <h4>MVCC Explained (for DevOps folks)</h4>
                    <p>MVCC is like Git for databases:</p>
                    <ul>
                        <li><strong>Snapshots:</strong> Each read gets a point-in-time view (like a Git commit)</li>
                        <li><strong>Concurrent Writes:</strong> Multiple processes can write; LanceDB merges automatically</li>
                        <li><strong>Conflict Resolution:</strong> Retry with exponential backoff (like Git push/pull)</li>
                    </ul>

                    <div class="code-block">
<pre># Multiple processes can safely:
# Process 1: Index directory A
chunkhound index /repo/frontend

# Process 2: Index directory B (simultaneously!)
chunkhound index /repo/backend

# LanceDB handles coordination automatically</pre>
                    </div>
                </div>
            </div>

            <h3>Parallel File Parsing</h3>
            <p>ChunkHound uses ProcessPoolExecutor for CPU-bound parsing:</p>

            <div class="code-block">
<pre># Parse files in parallel across CPU cores
with ProcessPoolExecutor(max_workers=8) as executor:
    # Each worker parses files independently
    parsed_files = executor.map(parse_file, file_list)

# Then insert to DB serially (through SerialDatabaseExecutor)
await serial_db.insert_chunks(all_chunks)</pre>
            </div>

            <div style="margin: 20px 0;">
                <div class="metric-card">
                    <h4>Sequential Parsing</h4>
                    <div class="value">100s</div>
                    <p>One file at a time</p>
                </div>
                <div class="metric-card">
                    <h4>Parallel Parsing (8 cores)</h4>
                    <div class="value">13s</div>
                    <p>7.7x speedup!</p>
                </div>
            </div>
        </section>

        <!-- Section 7: Performance Optimizations -->
        <section id="performance" class="section">
            <h2>Performance Optimizations: The Numbers That Matter</h2>

            <h3>Batching: The 100x Multiplier</h3>
            <p>ChunkHound's most critical optimization is batching API calls:</p>

            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Operation</th>
                        <th>Unbatched</th>
                        <th>Batched</th>
                        <th>Speedup</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Embeddings (1000 texts)</td>
                        <td>100 seconds</td>
                        <td>1 second</td>
                        <td><strong>100x</strong></td>
                    </tr>
                    <tr>
                        <td>DB inserts (5000 chunks)</td>
                        <td>250 seconds</td>
                        <td>1 second</td>
                        <td><strong>250x</strong></td>
                    </tr>
                    <tr>
                        <td>File updates (1000 chunks)</td>
                        <td>60 seconds</td>
                        <td>5 seconds</td>
                        <td><strong>12x</strong></td>
                    </tr>
                </tbody>
            </table>

            <div class="warning-box">
                <strong>Anti-Pattern Alert:</strong>
                NEVER make single-row DB inserts in loops! Always batch operations.
                <div class="code-block">
<pre># ‚ùå SLOW - Don't do this
for chunk in chunks:
    db.insert(chunk)  # 5000 round-trips!

# ‚úÖ FAST - Do this
db.insert_batch(chunks)  # 1 batch operation</pre>
                </div>
            </div>

            <h3>Index Optimization Strategy</h3>
            <p>Vector indexes speed up searches but slow down inserts. ChunkHound drops them during bulk loads:</p>

            <div class="interactive-demo">
                <h4>Index Strategy Calculator</h4>
                <p>How many chunks are you inserting?</p>
                <input type="number" class="demo-input" id="chunkCount" placeholder="e.g., 1000" value="100">
                <button class="demo-button" onclick="calculateIndexStrategy()">Calculate Strategy</button>
                <div class="demo-output" id="indexStrategyOutput">Results will appear here...</div>
            </div>

            <h3>Embedding Batching Configuration</h3>
            <p>ChunkHound intelligently batches embeddings based on provider limits:</p>

            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Provider</th>
                        <th>Batch Size</th>
                        <th>Concurrent Batches</th>
                        <th>Rate Limits</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>OpenAI</td>
                        <td>100</td>
                        <td>5</td>
                        <td>10k RPM</td>
                    </tr>
                    <tr>
                        <td>Ollama (local)</td>
                        <td>50</td>
                        <td>1</td>
                        <td>No limits</td>
                    </tr>
                    <tr>
                        <td>VoyageAI</td>
                        <td>128</td>
                        <td>10</td>
                        <td>Higher limits</td>
                    </tr>
                </tbody>
            </table>

            <h3>Memory Management</h3>
            <p>ChunkHound processes large codebases without running out of memory:</p>

            <ul>
                <li><strong>Streaming Parsing:</strong> Process files in batches, not all at once</li>
                <li><strong>Chunk Batching:</strong> Insert chunks in configurable batch sizes</li>
                <li><strong>File Batching:</strong> Limit number of files in memory</li>
            </ul>

            <div class="code-block">
<pre># Configuration controls memory usage
export CHUNKHOUND_INDEXING__CHUNK_BATCH_SIZE=1000   # Chunks per DB insert
export CHUNKHOUND_INDEXING__FILE_BATCH_SIZE=100     # Files processed at once
export CHUNKHOUND_EMBEDDING__BATCH_SIZE=100         # Texts per API call</pre>
            </div>

            <h3>Real-World Performance</h3>
            <div style="margin: 20px 0;">
                <div class="metric-card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                    <h4>Large Codebase (10k files)</h4>
                    <div class="value">~5 min</div>
                    <p>First-time indexing</p>
                </div>
                <div class="metric-card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                    <h4>Incremental Update (100 files)</h4>
                    <div class="value">~30 sec</div>
                    <p>Only re-index changed files</p>
                </div>
                <div class="metric-card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                    <h4>Semantic Search</h4>
                    <div class="value">~100ms</div>
                    <p>Top 10 results</p>
                </div>
            </div>
        </section>

        <!-- Section 8: MCP Protocol -->
        <section id="mcp" class="section">
            <h2>MCP: Connecting AI Assistants to Code</h2>

            <div class="concept-box">
                <h3>What is MCP?</h3>
                <p><strong>Model Context Protocol (MCP)</strong> - A standard way for AI assistants to connect to external tools and data sources. Think of it as an API for AI agents.</p>
            </div>

            <h3>How MCP Works</h3>
            <div class="visual-diagram">
                <div style="text-align: left; max-width: 800px; margin: 0 auto;">
                    <div class="architecture-box" style="display: block; margin: 10px 0;">
                        AI Assistant (Claude, GPT)
                    </div>
                    <div style="text-align: center; font-size: 2em; color: #667eea;">‚ÜïÔ∏è</div>
                    <div class="architecture-box" style="display: block; margin: 10px 0;">
                        MCP Protocol (JSON-RPC)
                    </div>
                    <div style="text-align: center; font-size: 2em; color: #667eea;">‚ÜïÔ∏è</div>
                    <div class="architecture-box" style="display: block; margin: 10px 0;">
                        ChunkHound MCP Server
                    </div>
                    <div style="text-align: center; font-size: 2em; color: #667eea;">‚ÜïÔ∏è</div>
                    <div class="architecture-box" style="display: block; margin: 10px 0;">
                        Your Indexed Codebase
                    </div>
                </div>
            </div>

            <h3>ChunkHound MCP Tools</h3>
            <p>When connected via MCP, AI assistants get these tools:</p>

            <button class="toggle-button" onclick="toggleSection('search-tool')">
                search_semantic - Find Similar Code
            </button>
            <div id="search-tool" class="toggle-content">
                <div style="padding: 20px;">
                    <p>Search for code chunks by semantic meaning:</p>
                    <div class="code-block">
<pre>User: "Find code that handles authentication timeouts"
AI: *uses search_semantic tool*
    query: "authentication timeout handling"
    limit: 10

Returns: Top 10 most relevant code chunks</pre>
                    </div>
                </div>
            </div>

            <button class="toggle-button" onclick="toggleSection('regex-tool')">
                search_regex - Pattern Matching
            </button>
            <div id="regex-tool" class="toggle-content">
                <div style="padding: 20px;">
                    <p>Traditional regex search across indexed code:</p>
                    <div class="code-block">
<pre>User: "Find all functions named authenticate_*"
AI: *uses search_regex tool*
    pattern: "def authenticate_\\w+\\("

Returns: All matching function definitions</pre>
                    </div>
                </div>
            </div>

            <button class="toggle-button" onclick="toggleSection('research-tool')">
                code_research - Deep Analysis with LLMs
            </button>
            <div id="research-tool" class="toggle-content">
                <div style="padding: 20px;">
                    <p>AI-powered deep research with iterative refinement:</p>
                    <div class="code-block">
<pre>User: "How does the authentication system work?"
AI: *uses code_research tool*
    query: "authentication system implementation"

ChunkHound:
1. Semantic search for relevant files
2. Cluster related code
3. Feed to LLM (Gemini/GPT/Claude)
4. LLM analyzes and summarizes
5. Returns comprehensive explanation</pre>
                    </div>
                    <p><strong>Multi-hop search:</strong> ChunkHound can iteratively expand search to related code, building a complete picture.</p>
                </div>
            </div>

            <h3>MCP Server Modes</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Mode</th>
                        <th>Use Case</th>
                        <th>Command</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>STDIO</strong></td>
                        <td>Claude Desktop integration</td>
                        <td><code>chunkhound mcp stdio</code></td>
                    </tr>
                    <tr>
                        <td><strong>HTTP</strong></td>
                        <td>Web UI, remote access</td>
                        <td><code>chunkhound mcp http --port 5173</code></td>
                    </tr>
                </tbody>
            </table>

            <div class="warning-box">
                <strong>STDIO Mode Constraint:</strong>
                STDIO mode uses stdin/stdout for JSON-RPC communication. This means NO print() statements or logging to stdout - it breaks the protocol! ChunkHound uses logging to stderr instead.
            </div>

            <h3>Setting Up MCP with Claude Desktop</h3>
            <div class="code-block">
<pre># 1. Install ChunkHound
pip install chunkhound

# 2. Index your codebase
chunkhound index /path/to/your/repo

# 3. Add to Claude Desktop config (~/.config/claude/claude_desktop_config.json)
{
  "mcpServers": {
    "chunkhound": {
      "command": "chunkhound",
      "args": ["mcp", "stdio"],
      "env": {
        "CHUNKHOUND_DATABASE__PATH": "/path/to/your/repo/.chunkhound/chunks.duckdb"
      }
    }
  }
}

# 4. Restart Claude Desktop - ChunkHound tools now available!</pre>
            </div>

            <div class="tip-box">
                <strong>DevOps Use Case:</strong>
                Set up ChunkHound for your infrastructure-as-code repos. AI assistants can now search your Terraform modules, Ansible playbooks, and Kubernetes manifests semantically!
            </div>
        </section>

        <!-- Section 9: DevOps Use Cases -->
        <section id="devops" class="section">
            <h2>ChunkHound for DevOps Engineers</h2>

            <h3>Use Case 1: Infrastructure as Code Search</h3>
            <div class="interactive-demo">
                <h4>Scenario: Finding Security Groups</h4>
                <p><strong>Problem:</strong> You have 100+ Terraform files. Where is the security group that allows port 3306?</p>

                <div class="code-block">
<pre># Traditional approach (limited)
grep -r "3306" terraform/
# Only finds literal "3306", misses variables

# ChunkHound semantic search
chunkhound search "security group allowing mysql database port"
# Finds: security groups with mysql, 3306, database access
# Even if using variables or different terminology!</pre>
                </div>
            </div>

            <h3>Use Case 2: Debugging Production Issues</h3>
            <div class="flex-container">
                <div class="flex-item">
                    <h4>Traditional Debugging</h4>
                    <ul>
                        <li>1. Read logs</li>
                        <li>2. Guess keywords</li>
                        <li>3. grep codebase</li>
                        <li>4. Manually trace code</li>
                        <li>5. Repeat if wrong path</li>
                    </ul>
                    <p style="margin-top: 10px; color: #ef4444;"><strong>Time: Hours</strong></p>
                </div>
                <div class="flex-item">
                    <h4>With ChunkHound + AI</h4>
                    <ul>
                        <li>1. Read logs</li>
                        <li>2. Ask AI: "Find code handling [error]"</li>
                        <li>3. AI uses code_research tool</li>
                        <li>4. Get relevant code + explanation</li>
                        <li>5. Fix faster</li>
                    </ul>
                    <p style="margin-top: 10px; color: #10b981;"><strong>Time: Minutes</strong></p>
                </div>
            </div>

            <h3>Use Case 3: Onboarding & Knowledge Transfer</h3>
            <p>New team member needs to understand your microservices:</p>

            <div class="code-block">
<pre>New Engineer: "How does the payment service communicate with the order service?"

AI (with ChunkHound):
1. Searches for "payment service order service communication"
2. Finds relevant API endpoints, message queues, and data contracts
3. Synthesizes a comprehensive explanation with code examples
4. Shows the actual implementation

Result: New engineer gets up to speed in 1 hour instead of 1 week!</pre>
            </div>

            <h3>Use Case 4: Security Audits</h3>
            <div class="tip-box">
                <strong>Example Queries:</strong>
                <ul>
                    <li>"Find all code that handles user authentication"</li>
                    <li>"Show me database queries that might be vulnerable to SQL injection"</li>
                    <li>"Find all places where we log sensitive data"</li>
                    <li>"Locate hardcoded credentials or API keys"</li>
                </ul>
                These semantic queries catch issues that regex patterns miss!
            </div>

            <h3>Use Case 5: Incident Response</h3>
            <div class="visual-diagram">
                <h4>2 AM Production Alert Scenario</h4>
                <div style="text-align: left; max-width: 700px; margin: 20px auto;">
                    <p><strong>Alert:</strong> "RDS connection pool exhausted"</p>
                    <div class="code-block" style="margin: 15px 0;">
<pre>You: Ask AI: "Find code that manages database connection pooling"

AI: *uses ChunkHound code_research*
- Finds connection pool configuration
- Identifies pool size settings
- Locates connection leak detection code
- Shows recent changes to pool management

You: Quickly identify the issue and deploy fix

Downtime: 15 minutes instead of 2 hours</pre>
                    </div>
                </div>
            </div>

            <h3>Use Case 6: Compliance Documentation</h3>
            <p>Generate documentation for compliance audits:</p>

            <div class="code-block">
<pre>Auditor: "Show me all code that handles PII (Personally Identifiable Information)"

AI with ChunkHound:
1. Semantic search: "personal information handling encryption storage"
2. Cluster related code files
3. Generate compliance report with:
   - Where PII is collected
   - How it's encrypted
   - Where it's stored
   - How it's deleted

Documentation generated automatically from actual code!</pre>
            </div>

            <h3>Setting Up ChunkHound for Your DevOps Workflow</h3>

            <button class="toggle-button" onclick="toggleSection('setup-step1')">
                Step 1: Index Your Repositories
            </button>
            <div id="setup-step1" class="toggle-content">
                <div style="padding: 20px;">
                    <div class="code-block">
<pre># Index your main codebase
chunkhound index /repos/main-app

# Index infrastructure code
chunkhound index /repos/terraform

# Index scripts and runbooks
chunkhound index /repos/devops-scripts

# Multiple repos? Index them separately or together
# Each gets its own .chunkhound/ directory</pre>
                    </div>
                </div>
            </div>

            <button class="toggle-button" onclick="toggleSection('setup-step2')">
                Step 2: Configure for Your Team
            </button>
            <div id="setup-step2" class="toggle-content">
                <div style="padding: 20px;">
                    <div class="code-block">
<pre># Create shared config: .chunkhound/config.json
{
  "database": {
    "provider": "lancedb",  # Multi-user safe
    "path": "/shared/chunkhound/db"
  },
  "embedding": {
    "provider": "openai",
    "model": "text-embedding-3-large",
    "api_key": "${OPENAI_API_KEY}"  # From environment
  },
  "indexing": {
    "file_extensions": [".py", ".tf", ".yaml", ".sh"],
    "ignore_patterns": ["venv/", "*.pyc", ".terraform/"]
  }
}</pre>
                    </div>
                </div>
            </div>

            <button class="toggle-button" onclick="toggleSection('setup-step3')">
                Step 3: Automate Re-Indexing
            </button>
            <div id="setup-step3" class="toggle-content">
                <div style="padding: 20px;">
                    <p>Keep your index fresh with CI/CD:</p>
                    <div class="code-block">
<pre># .github/workflows/chunkhound-reindex.yml
name: Re-index Codebase
on:
  push:
    branches: [main]
  schedule:
    - cron: '0 2 * * *'  # Daily at 2 AM

jobs:
  reindex:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup Python
        uses: actions/setup-python@v4
      - name: Install ChunkHound
        run: pip install chunkhound
      - name: Re-index
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: chunkhound index .
      - name: Upload index
        run: |
          aws s3 sync .chunkhound/ s3://company-chunkhound/repo-name/</pre>
                    </div>
                </div>
            </div>

            <h3>Team Adoption Tips</h3>
            <ul>
                <li><strong>Start Small:</strong> Index one critical repo first</li>
                <li><strong>Document Queries:</strong> Share effective search queries with team</li>
                <li><strong>Integrate with Slack:</strong> Bot that answers code questions</li>
                <li><strong>Runbook Assistant:</strong> AI that helps follow incident response procedures</li>
                <li><strong>Measure Impact:</strong> Track time saved in incident response</li>
            </ul>
        </section>

        <!-- Final Section: Quick Reference -->
        <section class="section">
            <h2>Quick Reference Card</h2>

            <div class="flex-container">
                <div class="flex-item">
                    <h3>Essential Commands</h3>
                    <div class="code-block">
<pre># Index a codebase
chunkhound index /path/to/repo

# Search semantically
chunkhound search "query"

# Search with regex
chunkhound search -r "pattern"

# Start MCP server
chunkhound mcp stdio
chunkhound mcp http --port 5173

# Check version
chunkhound --version</pre>
                    </div>
                </div>

                <div class="flex-item">
                    <h3>Key Concepts</h3>
                    <ul>
                        <li><strong>Embedding:</strong> Vector representing text meaning</li>
                        <li><strong>Semantic Search:</strong> Search by meaning, not keywords</li>
                        <li><strong>Vector DB:</strong> Database optimized for embeddings</li>
                        <li><strong>HNSW Index:</strong> Fast approximate nearest neighbor search</li>
                        <li><strong>MCP:</strong> Protocol for AI tools</li>
                        <li><strong>Batching:</strong> Process multiple items together (100x faster)</li>
                    </ul>
                </div>
            </div>

            <div class="tip-box">
                <strong>Remember:</strong>
                <ul>
                    <li>Always batch operations when possible</li>
                    <li>DuckDB = single-threaded only</li>
                    <li>LanceDB = multi-process safe</li>
                    <li>Embeddings are expensive - cache them!</li>
                    <li>Drop indexes before bulk inserts</li>
                </ul>
            </div>

            <h3>Troubleshooting</h3>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Error</th>
                        <th>Cause</th>
                        <th>Solution</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>"database is locked"</td>
                        <td>Concurrent DuckDB access</td>
                        <td>Use LanceDB or ensure single process</td>
                    </tr>
                    <tr>
                        <td>"Rate limit exceeded"</td>
                        <td>Too many API calls</td>
                        <td>Reduce embedding_batch_size</td>
                    </tr>
                    <tr>
                        <td>"Out of memory"</td>
                        <td>Processing too much at once</td>
                        <td>Reduce chunk_batch_size</td>
                    </tr>
                    <tr>
                        <td>JSON-RPC errors</td>
                        <td>print() in MCP server</td>
                        <td>Use logging to stderr instead</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <footer>
            <h2>Ready to Transform Your Codebase?</h2>
            <p>Start with: <code>pip install chunkhound</code></p>
            <p style="margin-top: 20px; opacity: 0.8;">
                Built 100% by AI agents ‚Ä¢ Open Source ‚Ä¢ Model Context Protocol
            </p>
        </footer>
    </div>

    <script>
        // Progress bar
        window.addEventListener('scroll', () => {
            const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
            const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            const scrolled = (winScroll / height) * 100;
            document.getElementById('progressBar').style.width = scrolled + '%';
        });

        // Toggle sections
        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            const button = event.target;

            section.classList.toggle('active');
            button.classList.toggle('active');
        }

        // Interactive demo: Compare similarity
        function compareSimilarity() {
            const text1 = document.getElementById('text1').value.toLowerCase();
            const text2 = document.getElementById('text2').value.toLowerCase();

            // Simple similarity calculation (word overlap)
            const words1 = new Set(text1.split(/\s+/));
            const words2 = new Set(text2.split(/\s+/));

            const intersection = new Set([...words1].filter(x => words2.has(x)));
            const union = new Set([...words1, ...words2]);

            const similarity = (intersection.size / union.size * 100).toFixed(1);

            const output = document.getElementById('similarityOutput');
            output.innerHTML = `
                <strong>Similarity Score: ${similarity}%</strong><br/>
                <em>(This is a simplified demo - real embeddings use neural networks!)</em><br/><br/>
                <strong>Shared concepts:</strong> ${[...intersection].join(', ') || 'None'}<br/>
                <strong>Text 1 unique:</strong> ${[...words1].filter(x => !words2.has(x)).join(', ') || 'None'}<br/>
                <strong>Text 2 unique:</strong> ${[...words2].filter(x => !words1.has(x)).join(', ') || 'None'}
            `;
        }

        // Interactive demo: Index strategy
        function calculateIndexStrategy() {
            const count = parseInt(document.getElementById('chunkCount').value) || 0;
            const output = document.getElementById('indexStrategyOutput');

            if (count < 50) {
                output.innerHTML = `
                    <strong>Strategy: Keep Index</strong><br/>
                    With ${count} chunks, the overhead of dropping and rebuilding the index exceeds the benefit.<br/><br/>
                    <strong>Estimated time:</strong> ~${(count * 0.01).toFixed(2)} seconds
                `;
            } else {
                const withIndex = count * 0.01;
                const withoutIndex = count * 0.001 + 0.5; // Drop, insert, rebuild
                const speedup = (withIndex / withoutIndex).toFixed(1);

                output.innerHTML = `
                    <strong>Strategy: Drop Index, Insert, Rebuild</strong><br/>
                    With ${count} chunks, dropping the index first is ${speedup}x faster!<br/><br/>
                    <strong>With index:</strong> ~${withIndex.toFixed(2)} seconds<br/>
                    <strong>Without index (then rebuild):</strong> ~${withoutIndex.toFixed(2)} seconds<br/>
                    <strong>Time saved:</strong> ~${(withIndex - withoutIndex).toFixed(2)} seconds
                `;
            }
        }

        // Smooth scrolling for navigation links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            });
        });

        // Initialize first demo with default values
        window.addEventListener('load', () => {
            compareSimilarity();
        });
    </script>
</body>
</html>
